WITH RECURSIVE pdx AS (
  SELECT el.stay_id, el.time_zero, icustays.intime, 
case
  when el.death_offset_days is not null and (el.death_offset_days * 24 * 60) < (el.time_zero + baseline_24h.vent_duration) then (el.death_offset_days * 24 * 60) - el.time_zero 
  else baseline_24h.vent_duration
end as last_time -- minutes after time_zero 
  FROM `roses-0.roses.mimic_eligibility_24h` AS el -- for 24h dataset
  LEFT JOIN `physionet-data.mimiciv_icu.icustays` AS icustays ON el.stay_id = icustays.stay_id
  LEFT JOIN `roses-0.roses.baseline_mimic_24h` as baseline_24h ON baseline_24h.stay_id = el.stay_id
  WHERE eligible = 1
)

, ranges AS (
  SELECT pdx.stay_id, last_time, 
  (DATETIME_DIFF(inp.starttime, intime, MINUTE) - time_zero) / @time_int as first_total_offset,
  FLOOR((DATETIME_DIFF(inp.starttime, intime, MINUTE) - time_zero) / @time_int) as first_interval, 
  (DATETIME_DIFF(inp.starttime, intime, MINUTE) - time_zero) / @time_int as first_interval_offset, 
  FLOOR((DATETIME_DIFF(inp.endtime, intime, MINUTE) - time_zero) / @time_int) as last_interval, 
  (DATETIME_DIFF(inp.endtime, intime, MINUTE) - time_zero) / @time_int as last_interval_offset,
  case 
    -- keep in smallest unit (mcg) unless unit is units
    when amountuom like "mg" then amount*1000
    else amount 
  end as amount, 
  case 
    -- the same as above, but creating a column that won't change in rec. select 
    when amountuom like "mg" then amount*1000
    else amount 
  end as total_amount, 
  case 
    when itemid = 222168 then "Propofol"
    when itemid = 221668 then "Midazolam"
    when itemid = 221385 then "Lorazepam"
    when itemid in (225150, 229420) then "Dexmedetomidine"
    when itemid = 221712 then "Ketamine"
    when itemid in (221744, 225942, 225972) then "Fentanyl"
    when itemid in (221833) then "Hydromorphone"
    when itemid in (225154) then "Morphine"
    when itemid in (221824) then "Haloperidol"
    when itemid = 225973 then "Meperidine" 
    when itemid = 221906 then "Norepinephrine"
    when itemid = 221662 then "Dopamine"
    when itemid = 222315 then "Vasopressin"  -- units, not mcg
    when itemid = 221289 then "Epinephrine"
    when itemid = 221653 then "Dobutamine"
    when itemid = 221986 then "Milrinone"
    when itemid = 221623 then "Diazepam"
    when itemid in (221555, 229233, 222062) then "Neuromuscular blocker"
  end as variable,
  0 as calculated -- column to determine whether value was generated by rec. call or not 
  from pdx
  left join `physionet-data.mimiciv_icu.inputevents` AS inp on inp.stay_id = pdx.stay_id
  WHERE inp.itemid IN (
    222168, -- propofol (mg, mcg)
    221668, -- Midazolam (mg)
    221385, -- Lorazepam (mg)
    225150, 229420, -- Dexmedetomidine {(a): (mg, mcg), (b): (mg, mcg)} -- overall in mcg
    221712, -- Ketamine (mg) -- overall in mg
    221744, 225942, 225972, -- Fentanyl -- {(a): (mg, mcg), (b): (mg, mcg), (c): (mcg)} 
    221833, -- Hydromorphone -- in mcg and dose, but only 1 dose in inputevents so dropping dose (see below) 
    225154, -- Morphine (mg)
    221824, -- Haloperidol (mg)
    221906, -- norepinephrine (mg)
    221662, -- dopamine (mg)
    222315, -- vasopressin (units)
    221289, -- epinephrine (mg, mcg)
    221653, -- dobutamine (mg)
    221986, -- milrinone (mg)
    221623,  -- diazepam (mg) 
    221555, -- cisatracurium
    229233  -- rocuronium
    , 222062 -- vecuronium (mg)
    , 225973 -- meperidine (mg) 
  ) and not (itemid = 221833 and amountuom like "dose") 
    and DATETIME_DIFF(inp.starttime, intime, MINUTE) >= (time_zero -  6*@time_int)
    -- keep only values after (including) time interval -1.0 
)


, calc as (
  select stay_id, last_time, first_total_offset, first_interval, first_interval_offset, 
  last_interval, last_interval_offset, amount, total_amount, variable, calculated
  from ranges

  union all 

  select stay_id, last_time, first_total_offset,
    case
      when (first_interval != last_interval and calculated = 0) then first_interval 
      when (last_interval != floor(last_interval_offset) and calculated = 1) then first_interval + 1
      when (first_interval != last_interval and floor(last_interval_offset) = last_interval and calculated = 1) then first_interval + 1
    end as first_interval, 
    case
      when (first_interval != last_interval and calculated = 0) then first_interval 
      when (last_interval != floor(last_interval_offset) and calculated = 1) then first_interval + 1
      when (first_interval != last_interval and floor(last_interval_offset) = last_interval and calculated = 1) then first_interval + 1
    end as first_interval_offset, 
    case
      when (first_interval != last_interval and calculated = 0) then first_interval + 1 
      when (last_interval != floor(last_interval_offset) and calculated = 1) then last_interval + 1
      when (first_interval != last_interval and floor(last_interval_offset) = last_interval and calculated = 1) then last_interval
    end as last_interval, 
    last_interval_offset, 
    case
      -- (amount / (end - start)) * (new_end - new_start) --> mg/int * int --> mg
      when (first_interval != last_interval and calculated = 0) 
        then (total_amount / (last_interval_offset - first_total_offset)) * ((first_interval + 1) - (first_interval))
      when (last_interval != floor(last_interval_offset) and calculated = 1) 
        then (total_amount / (last_interval_offset - first_total_offset)) * ((last_interval + 1) - (first_interval + 1))
      when (first_interval != last_interval and floor(last_interval_offset) = last_interval and calculated = 1) 
        then (total_amount / (last_interval_offset - first_total_offset)) * (last_interval_offset - last_interval)
    end as amount, 
    total_amount,
    variable,
    1 as calculated
  from calc
  where 
    ((first_interval != last_interval and calculated = 0) -- first discrepency 
    or (last_interval != floor(last_interval_offset) and calculated = 1) -- getting closer to end interval 
    or (first_interval != last_interval and floor(last_interval_offset) = last_interval and calculated = 1)) -- last interval   
)

select stay_id, first_interval as time_interval, variable, 
case when variable like "Neuromuscular blocker" then 1
else sum(amount) 
end as value
from calc
where (first_interval = last_interval or calculated = 1) -- where not (first != last & calculated = 0)
and ( first_interval <= 24*7*60/@time_int -- only get values within first 7 days
      and 
      first_interval <= last_time/@time_int  -- only get values while in first invasive ventilation 
    )
group by 1, 2, 3
